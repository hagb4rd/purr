module Phemme.Core {
  # -- Decorators ------------------------------------------------------
  [| doc: "Attachs documentation to an object." |]
  export _ doc: $text ^String? => ffi "(function($data) {
    $data.$doc = $text;
    return $data
  })"

  [| doc: "Retrieves the documentation from an object." |]
  export $data doc => ffi "_data.$doc || '(No documentation available)'"

  # -- Utilities -------------------------------------------------------
  export $error raise => ffi "(function() {
    throw new Error($error)
  })()" where $message = $error show

  export _ otherwise => true

  export $x tag => ffi "$self.$tag($x)"

  # -- Contracts -------------------------------------------------------
  export $x Number? => ffi "typeof $x === 'number'"
  export $x String? => ffi "typeof $x === 'string'"
  export $x Boolean? => ffi "typeof $x === 'boolean'" 

  # -- Protocols -------------------------------------------------------
  [| doc: """
          The type of things that can be structurally compared.

          A minimal implementation for this interface is to provide the
          `==` operator, which compares two values of the same type
          structurally, and returns either true or false.

          The implementation may also provide the `=/=` operator, in
          case the value isn't reflexively equal (e.g.: NaN). 
          """
  |]
  export interface Equality {
    method $this == $that -> Boolean?
    method $this =/= $that -> Boolean? => not($this == $that)
  }

  [| doc: """
          The type of things that have some comparable order.

          A minimal implementation of this type should provide the
          `compare-to:` function, which returns an `Ordering`.
          """
  |]
  export interface Ordered {
    need Equality
    method $this compare-to: $that -> Ordering?
    method $this <  $that => ($this compare-to: $that) ==  Less
    method $this <= $that => ($this compare-to: $that) =/= Greater
    method $this >  $that => ($this compare-to: $that) ==  Greater
    method $this >= $that => ($this compare-to: $that) =/= Less
    method $this max: $that => if $this > $that then $this 
                                                else $that
    method $this min: $that => if $this < $that then $this 
                                                else $that
  }

  [| doc: """The type of things that have a textual representation.""" |]
  export interface Representable {
    method $this show -> String?
  }

  [| doc: """The type of things that have boundaries.""" |]
  export interface Bounded {
    method $this upper-bound
    method $this lower-bound
  }

  [| doc: """The type of things we can enumerate.""" |]
  export interface Enumerable {
    need Bounded
    need Ordered
    method $this successor
    method $this predecessor
    method $start up-to: $end => let $next = $start successor
                                   | $max  = $end max: $start upper-bound
                                 in
                                   if $next >= $max then
                                     Nil
                                   else
                                     $start :: ($next up-to: $end)
  }

  [| doc: """The type of things that can be indexed.""" |]
  export interface Indexable {
    method $this at: $index ^Number?
    method $this includes?: $index -> Boolean? => case $this at: $index of
                                                  | Nothing => false
                                                  | _       => true
  }

  [| doc: """The type of things that can be converted to JSON.""" |]
  export interface JsonSerialisable {
    method $this to-json -> String?
    method $protocol from-json: $value ^String?
  }

  [| doc: """The type of things that form a Semigroup.""" |]
  export interface Semigroup {
    method $this + $that
  }

  [| doc: """The type of things that form a Monoid.""" |]
  export interface Monoid {
    need Semigroup
    method $this empty
  }

  [| doc: """The type of things that can be mapped over.""" |]
  export interface Mappable {
    method $this map: $transformation
  }

  [| doc: """The type of things that can be applied as functions.""" |]
  export interface Applicative {
    need Mappable
    method $this of: $value
    method $this apply-to: $a-mappable
    method $this <*> $a-mappable => $this apply-to: $a-mappable
  }

  [| doc: """The type of things that can be chained.""" |]
  export interface Chainable {
    need Applicative
    method $this chain: $transformation
    method $this >>= $transformation => $this chain: $transformation
  }

  # -- Basic data types ------------------------------------------------
  export data Ordering = Less | Equal | Greater

  
  # -- Boolean ---------------------------------------------------------
  # implicitly `data Boolean = true | false`

  implement Equality for Boolean {
    method $a == $b => ffi "$a === $b"
  }

  implement Ordered for Boolean {
    method $a compare-to: $b => case $a, $b of
    | true, false => Less
    | false, true => Greater
    | _           => Equal
  }

  implement Representable for Boolean {
    method $a show => ffi "$a.toString()"
  }

  implement Bounded for Boolean {
    method $a upper-bound => true
    method $a lower-bound => false
  }

  implement Enumerable for Boolean {
    method $a successor => case $a of
                           | false => true
    method $a predecessor => case $a of
                             | true => false
  }

  implement JsonSerialisable for Boolean {
    method $a to-json => ffi "JSON.stringify($a)"
    method $protocol from-json: $text -> Boolean? => ffi "JSON.parse($text)"
  }

  export $a ^Boolean? && $b ^Boolean? => ffi "$a && $b"

  export $a ^Boolean? || $b ^Boolean? => ffi "$a || $b"

  export not($a ^Boolean?) => ffi "!$a"

  export $a ^Boolean? negate => ffi "!$a"

  export $test ^Boolean? then: $consequent else: $alternate =>
  | test      => consequent()
  | otherwise => alternate()



  # -- Number ----------------------------------------------------------
  implement Equality for Number {
    method $this == $that => ffi "$this === $that"
    method $this =/= $that => ffi "$this !== $that"
  }

  implement Ordered for Number {
    method $this compare-to: $that ^Number? => 
         | ($this < $that) => Less
         | ($this > $that) => Greater
         | otherwise       => Equal

    method $this <  $that ^Number? => ffi "$this < $that"
    method $this >  $that ^Number? => ffi "$this > $that"
    method $this <= $that ^Number? => ffi "$this <= $that"
    method $this >= $that ^Number? => ffi "$this >= $that"
  }

  implement Representable for Number {
    method $this show => ffi "$this.toString()"
  }

  implement Bounded for Number {
    method $this upper-bound => ffi "$this.MIN_VALUE"
    method $this lower-bound => ffi "$this.MIN_VALUE"
  }

  implement Enumerable for Number {
    method $this successor => ffi "$this + 1"
    method $this predecessor => ffi "$this - 1"
  }

  implement JsonSerialisable for Number {
    method $this to-json => ffi "JSON.stringify($this)"
    method $protocol from-json: $value -> Number? => ffi "JSON.parse($value)"
  }

  implement Semigroup for Number {
    method $this + $that ^Number? => ffi "$this + $that"
  }

  implement Monoid for Number {
    method $this empty => 0
  }

  export $this ^Number? - $that ^Number? => ffi "$this - $that"

  export $this ^Number? * $that ^Number? => ffi "$this * $that"

  export $this ^Number? / $that ^Number? => ffi "$this / $that" # "

  export $this ^Number? modulus: $that ^Number? => ffi "$this % $that"

  export $this ^Number? absolute => ffi "Math.abs($this)"

  export $this ^Number? floor => ffi "Math.floor($this)"

  export $this ^Number? ceil => ffi "Math.ceil($this)"

  export $this ^Number? round => ffi "Math.round($this)"


  export $this ^Number? square-root => ffi "Math.sqrt($this)"

  export $this ^Number? divided-by: $that ^Number? => $quotient - $quotient floor
                                                      where 
                                                        $quotient = $this / $that

  export $this ^Number? is-even? => ($this modulus: $that) == 0
  export $this ^Number? is-odd? => ($this modulus: $that) =/= 0

  export $this ^Number? acos => ffi "Math.acos($this)"
  export $this ^Number? asin => ffi "Math.asin($this)"
  export $this ^Number? atan => ffi "Math.atan($this)"
  export $this ^Number? cos => ffi "Math.cos($this)"
  export $this ^Number? exp => ffi "Math.exp($this)"
  export $this ^Number? log => ffi "Math.log($this)"
  export $this ^Number? pow => ffi "Math.pow($this)"
  export $this ^Number? sin => ffi "Math.sin($this)"
  export $this ^Number? tan => ffi "Math.tan($this)"
  
  # Constants
  export $this PI => ffi "Math.PI"
  

  # -- Strings ---------------------------------------------------------
  # built-in `String ~= [Char]`
  implement Equality for String {
    method $this == $that => ffi "$this === $that"
  }

  implement Representable for String {
    method $this show => ffi "$this"
  }

  implement Semigroup for String {
    method $this + $that ^String? => ffi "$this + $that"
  }

  implement Monoid for String {
    method $this empty => ""
  }

  # TODO: use a Character class to represent JS's conventional 1-length strings
  
  export $this ^String? upcase     => ffi "$this.toUpperCase()"
  export $this ^String? downcase   => ffi "$this.toLowerCase()"
  export $this ^String? trim       => ffi "$this.trim()"
  export $this ^String? trim-left  => ffi "$this.trimLeft()"
  export $this ^String? trim-right => ffi "$this.trimRight()"


  # -- Maybe -----------------------------------------------------------
  export data Maybe = Nothing | Just(_)

  implement Equality for Maybe {
    method $this == $that ^Maybe? => case $this, $that of
                                     | Nothing, Nothing   => true
                                     | Just($a), Just($b) => $a == $b
                                     | _, _               => false
  }

  implement Representable for Maybe {
    method $this show => case $this of
                         | Nothing  => "Nothing"
                         | Just($a) => "Just(" + $a show + ")"
  }

  implement Semigroup for Maybe {
    method $this + $that => case $this, $that of
                            | Just($a), Just($b) => ($a + $b) Just
                            | _, _               => Nothing
  }

  implement Monoid for Maybe {
    method $this empty => Nothing
  }

  implement Mappable for Maybe {
    method $this map: $f => case $this of
                            | Nothing  => Nothing
                            | Just($a) => $f($a) Just
  }

  implement Applicative for Maybe {
    method $protocol of: $value => value Just
    method $this apply-to: $that => case $this of
                                    | Nothing  => $that
                                    | Just($f) => $that map: $f
  }

  implement Chainable for Maybe {
    method $this chain: $f => case $this of
                              | Nothing  => Nothing
                              | Just($a) => $f($a)
  }

  # -- Either ----------------------------------------------------------
  export data Either = Failure(_) | Success(_)


  # -- Function --------------------------------------------------------
  export $a identity => $a
  export $a constant => $b => $a
  export $f ->> $g => $a => $f($g($a))
  export $f <<- $g => $a => $g($f($a))
  export $f flip => $a $b => $f($b, $a)


  # -- Lists -----------------------------------------------------------
  export data List = Nil | _ :: _ ^List?
 
  export $xs filter: $f => case $xs of
    | Nil         => Nil
    | $x :: $rest => if $f($x) then $x :: $rest filter: $f
                               else $rest filter: $f

  export $xs first => case $xs of
    | Nil     => Nothing
    | $a :: _ => $a Just

  export $xs first! => case $xs of
    | $a :: _ => $a

  export $xs rest => case $xs of
    | Nil        => Nothing
    | _ :: $rest => $rest

  export $xs last => case $xs of
    | Nil        => Nothing
    | $a :: Nil  => a Just
    | _ :: $rest => $rest last

  export $xs last! => case $xs of
    | $a :: Nil  => $a
    | _ :: $rest => $rest last!

  export $xs is-empty? => case $xs of
    | Nil    => true
    | _ :: _ => false

  export $xs ^List? fold: $f from: $b => ffi "(function() {
    while (true) {
      if ($xs.$$ctag === 'Nil')  return $b
      if ($xs.$$ctag !== '::')  throw new TypeError('Not a List.')
      var v = $xs.$0
      $b = _f($b, v)
      $xs = $xs.$1
    }
  })()"

  export $xs reverse => $xs fold: (_ :: _) flip from: Nil

  export $xs fold-right: $f from: $b => $xs reverse fold: $f from: $b

  export $xs length => $xs fold: ($a _ => $a + 1) from: 0


}
