module {
  # -- Protocols -------------------------------------------------------
  [| doc: """
          The type of things that can be structurally compared.

          A minimal implementation for this interface is to provide the
          `==` operator, which compares two values of the same type
          structurally, and returns either true or false.

          The implementation may also provide the `=/=` operator, in
          case the value isn't reflexively equal (e.g.: NaN). 
          """
  |]
  export interface Equality {
    method this == b
    method this =/= b => not(this == b)
  }

  [| doc: """
          The type of things that have some comparable order.

          A minimal implementation of this type should provide the
          `compare-to:` function, which returns an `Ordering`.
          """
  |]
  export interface Ordered {
    need @Equality
    method this compare-to: b
    method this < b  => (this compare-to: b) == Less
    method this <= b => (this compare-to: b) =/= Greater
    method this > b  => (this compare-to: b) == Greater
    method this >= b => (this compare-to: b) =/= Less
    method this max: b => if this > b then this else b
    method this min: b => if this < b then this else b
  }

  [| doc: """The type of things that have a textual representation.""" |]
  export interface Representable {
    method this show
  }

  [| doc: """The type of things that have boundaries.""" |]
  export interface Bounded {
    method this upper-bound
    method this lower-bound
  }

  [| doc: """The type of things we can enumerate.""" |]
  export interface Enumerable {
    need @Bounded
    need @Ordered
    method this sucessor
    method this predecessor
    method start up-to: end => let next = start successor
                                 | max  = end max: start upper-bound
                               in
                                 if next >= max then
                                   @Nil
                                 else
                                   start :: (next up-to: end)
  }

  [| doc: """The type of things that can be indexed.""" |]
  export interface Indexable {
    method this at: index
    method this includes?: index => case this at: index of
                                    | Nothing => false
                                    | _       => true
  }

  [| doc: """The type of things that can be converted to JSON.""" |]
  export interface JsonSerialisable {
    method this to-json
    method protocol from-json: value
  }

  [| doc: """The type of things that form a Semigroup.""" |]
  export interface Semigroup {
    method this + that
  }

  [| doc: """The type of things that form a Monoid.""" |]
  export interface Monoid {
    need @Semigroup
    method this empty
  }

  [| doc: """The type of things that can be mapped over.""" |]
  export interface Mappable {
    method this map: transformation
  }

  [| doc: """The type of things that can be applied as functions.""" |]
  export interface Applicative {
    need @Mappable
    method this of: value
    method this apply-to: a-mappable
    method this <*> a-mappable => this apply-to: a-mappable
  }

  [| doc: """The type of things that can be chained.""" |]
  export interface Chainable {
    need @Applicative
    method this chain: transformation
    method this >>= transformation => this chain: transformation
  }

  # -- Basic data types ------------------------------------------------
  export data Ordering = Less | Equal | Greater

  
  # -- Boolean ---------------------------------------------------------
  # implicitly `data Boolean = true | false`

  implement @Equality for @Boolean {
    method a == b => ffi "_a === _b"
  }

  implement @Ordered for @Boolean {
    method a compare-to: b => case a of
    | true  => if b == true then @Equal else @Less
    | false => if b == false then @Equal else @Greater
  }

  implement @Representable for @Boolean {
    method a show => ffi "_a.toString()"
  }

  implement @Bounded for @Boolean {
    method a upper-bound => true
    method a lower-bound => false
  }

  implement @Enumerable for @Boolean {
    method a successor => case a of
                          | false => true
    method a predecessor => case a of
                            | true => false
  }

  implement @JsonSerialisable for @Boolean {
    method a to-json => ffi "JSON.stringify(a)"
    method protocol from-json: text => ffi "$Phemme.ensureBoolean(JSON.parse(text))"
  }

  export a /\ b => ffi "$Phemme.ensureBoolean(_a) && $Phemme.ensureBoolean(_b)"
  export a \/ b => ffi "$Phemme.ensureBoolean(_a) || $Phemme.ensureBoolean(_b)"
  export not(a) => ffi "!$Phemme.ensureBoolean(_a)"
  export a negate => ffi "!$Phemme.ensureBoolean(_a)"
  export test then: consequent else: alternate => if test then
                                                    consequent()
                                                  else
                                                    alternate()


  # -- Number ----------------------------------------------------------
  implement @Equality for @Number {
    method this == that => ffi "_this === _that"
    method this =/= that => ffi "_this !== _that"
  }

  implement @Ordered for @Number {
    method this compare-to: that => if this < that      then Less
                                    else if this > that then Greater
                                    else                     Equal
    method this < that  => ffi "_this < $Phemme.ensureNumber(_that)"
    method this > that  => ffi "_this > $Phemme.ensureNumber(_that)"
    method this <= that => ffi "_this <= $Phemme.ensureNumber(_that)"
    method this >= that => ffi "_this >= $Phemme.ensureNumber(_that)"
  }

  implement @Representable for @Number {
    method this show => ffi "_this.toString()"
  }

  implement @Bounded for @Number {
    method this upper-bound => ffi "_this.MIN_VALUE"
    method this lower-bound => ffi "_this.MIN_VALUE"
  }

  implement @Enumerable for @Number {
    method this successor => ffi "_this + 1"
    method this predecessor => ffi "_this - 1"
  }

  implement @JsonSerialisable for @Number {
    method this to-json => ffi "JSON.stringify(_this)"
    method protocol from-json: value => ffi "$Phemme.ensureNumber(JSON.parse(value))"
  }

  implement @Semigroup for @Number {
    method this + that => ffi "_this + $Phemme.ensureNumber(_that)"
  }

  implement @Monoid for @Number {
    method this empty => 0
  }

  export this - that => ffi "$Phemme.ensureNumber(_this) - $Phemme.ensureNumber(_that)"

  export this * that => ffi "$Phemme.ensureNumber(_this) * $Phemme.ensureNumber(_that)"

  export this / that => ffi "$Phemme.ensureNumber(_this) / $Phemme.ensureNumber(_that)"

  export this modulus: that => ffi "$Phemme.ensureNumber(_this) % $Phemme.ensureNumber(_that)"

  export this absolute => ffi "Math.abs($Phemme.ensureNumber(_this))"

  export this floor => ffi "Math.floor($Phemme.ensureNumber(_this))"

  export this ceil => ffi "Math.ceil($Phemme.ensureNumber(_this))"

  export this round => ffi "Math.round($Phemme.ensureNumber(_this))"


  export this square-root => ffi "Math.sqrt($Phemme.ensureNumber(_this))"

  export this divided-by: that => quotient - quotient floor
                                  where quotient = this / that

  export this is-even? => (this modulus: that) == 0
  export this is-odd? => (this modulus: that) =/= 0

  export this acos => ffi "Math.acos($Phemme.ensureNumber(_this))"
  export this asin => ffi "Math.asin($Phemme.ensureNumber(_this))"
  export this atan => ffi "Math.atan($Phemme.ensureNumber(_this))"
  export this cos => ffi "Math.cos($Phemme.ensureNumber(_this))"
  export this exp => ffi "Math.exp($Phemme.ensureNumber(_this))"
  export this log => ffi "Math.log($Phemme.ensureNumber(_this))"
  export this pow => ffi "Math.pow($Phemme.ensureNumber(_this))"
  export this sin => ffi "Math.sin($Phemme.ensureNumber(_this))"
  export this tan => ffi "Math.tan($Phemme.ensureNumber(_this))"
  
  # Constants
  export this PI => ffi "Math.PI"
  

  # -- Strings ---------------------------------------------------------
  # built-in `String ~= [Char]`
  implement @Equality for @String {
    method this == that => ffi "_this === _that"
  }

  implement @Representable for @String {
    method this show => ffi "_this"
  }

  # TODO: use a Character class to represent JS's conventional 1-length strings
  
  export this upcase => ffi "$Phemme.ensureString(_this).toUpperCase()"
  export this downcase => ffi "$Phemme.ensureString(_this).toLowerCase()"
  export this trim => ffi "$Phemme.ensureString(_this).trim()"
  export this trim-left => ffi "$Phemme.ensureString(_this).trimLeft()"
  export this trim-right => ffi "$Phemme.ensureString(_this).trimRight()"


  # -- Maybe -----------------------------------------------------------
  export data Maybe = Nothing | Just(value)

  implement @Equality for @Maybe {
    method this == that => case this of
                           | Nothing  => case that of
                                         | Nothing => true
                                         | Just(_) => false
                           | Just($a) => case that of
                                         | Nothing  => false
                                         | Just($b) => a == b
  }

  implement @Representable for @Maybe {
    method this show => case this of
                        | Nothing  => "Nothing"
                        | Just($a) => "Just(" + a show + ")"
  }

  implement @Semigroup for @Maybe {
    method this + that => case this of
                          | Nothing  => @Nothing
                          | Just($a) => case that of
                                        | Nothing  => @Nothing
                                        | Just($b) => self.Just(a + b)
  }

  implement @Monoid for @Maybe {
    method this empty => @Nothing
  }

  implement @Mappable for @Maybe {
    method this map: f => case this of
                          | Nothing  => @Nothing
                          | Just($a) => self.Just(f(a))
  }

  implement @Applicative for @Maybe {
    method protocol of: value => self.Just(value)
    method this apply-to: that => case this of
                                  | Nothing  => that
                                  | Just($f) => that map: f
  }

  implement @Chainable for @Maybe {
    method this chain: f => case this of
                            | Nothing  => Nothing
                            | Just($a) => f(a)
  }

  # -- Either ----------------------------------------------------------
  export data Either = Failure(value) | Success(value)


  # -- Function --------------------------------------------------------
  export a identity => a
  export a constant => b => a
  export f ->> g => a => f(g(a))
  export f <<- g => a => g(f(a))
  export a |> f => f(a)
  export f <| a => f(a)

  # -- Lists ----------------------------------------------------------- 
  export data List = Nil | value :: otherList  
 
  export xs filter: f => case xs of
                         | Nil         => @Nil
                         | $x :: $rest => if f(x) then $x :: $rest filter: f
                                                  else $rest filter: f

  export xs first => case xs of
                     | Nil     => @Nothing
                     | $a :: _ => self.Just(a)

  export xs first! => case xs of
                      | $a :: _ => a

  export xs rest => case xs of
                    | Nil        => @Nothing
                    | _ :: $rest => rest

  export xs last => case xs of
                    | Nil        => @Nothing
                    | $a :: Nil  => self.Just(a)
                    | _ :: $rest => $rest last

  export xs last! => case xs of
                     | $a :: Nil  => a
                     | _ :: $rest => $rest last!

  export xs is-empty? => case xs of
                         | Nil    => true
                         | _ :: _ => false

  export xs length => case xs of
                      | Nil        => 0
                      | _ :: $rest => 1 + $rest length

  
}

let $a ^number? + $b ^number? -> ^number? => ...
     # ^ pre         ^ pre       ^ post
