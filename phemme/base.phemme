module {
  # -- Decorators ------------------------------------------------------
  [| doc: "Attachs documentation to an object." |]
  export _ doc: $text ^string? => ffi "(function(_data) {
    _data.$doc = _text;
    return _data
  })"

  [| doc: "Retrieves the documentation from an object." |]
  export $data doc => ffi "_data.$doc || '(No documentation available)'"

  # -- Utilities -------------------------------------------------------
  export $error raise => ffi "(function() {
    throw new Error(_message)
  })()" where $message = $error show

  export _ otherwise => true

  # -- Contracts -------------------------------------------------------
  export $x number? =>
  | ffi "typeof _x === 'number'" => $x
  | otherwise                    => "Not a number." raise

  export $x string? =>
  | ffi "typeof _x === 'string'" => $x
  | otherwise                    => "Not a string." raise

  export $x boolean? =>
  | ffi "typeof _x === 'boolean'" => $x
  | otherwise                     => "Not a boolean." raise

  export $x ordering? =>
  | ffi "_x.$$name === 'Ordering'" => $x
  | otherwise                      => "Not an Ordering instance." raise

  export $x maybe? =>
  | ffi "_x.$$name === 'Maybe'" => $x
  | otherwise                   => "Not a Maybe instance." raise

  export $x list? =>
  | ffi "_x.$$name === 'List'" => $x
  | otherwise                  => "Not a List instance." raise

  # -- Protocols -------------------------------------------------------
  [| doc: """
          The type of things that can be structurally compared.

          A minimal implementation for this interface is to provide the
          `==` operator, which compares two values of the same type
          structurally, and returns either true or false.

          The implementation may also provide the `=/=` operator, in
          case the value isn't reflexively equal (e.g.: NaN). 
          """
  |]
  export interface Equality {
    method $this == $that -> boolean?
    method $this =/= $that -> boolean? => not($this == $that)
  }

  [| doc: """
          The type of things that have some comparable order.

          A minimal implementation of this type should provide the
          `compare-to:` function, which returns an `Ordering`.
          """
  |]
  export interface Ordered {
    need Equality
    method $this compare-to: $that -> ordering?
    method $this <  $that => ($this compare-to: $that) ==  Less
    method $this <= $that => ($this compare-to: $that) =/= Greater
    method $this >  $that => ($this compare-to: $that) ==  Greater
    method $this >= $that => ($this compare-to: $that) =/= Less
    method $this max: $that => if $this > $that then $this 
                                                else $that
    method $this min: $that => if $this < $that then $this 
                                                else $that
  }

  [| doc: """The type of things that have a textual representation.""" |]
  export interface Representable {
    method $this show -> string?
  }

  [| doc: """The type of things that have boundaries.""" |]
  export interface Bounded {
    method $this upper-bound
    method $this lower-bound
  }

  [| doc: """The type of things we can enumerate.""" |]
  export interface Enumerable {
    need Bounded
    need Ordered
    method $this successor
    method $this predecessor
    method $start up-to: $end => let $next = $start successor
                                   | $max  = $end max: $start upper-bound
                                 in
                                   if $next >= $max then
                                     Nil
                                   else
                                     $start :: ($next up-to: $end)
  }

  [| doc: """The type of things that can be indexed.""" |]
  export interface Indexable {
    method $this at: $index ^number?
    method $this includes?: $index -> boolean? => case $this at: $index of
                                                  | Nothing => false
                                                  | _       => true
  }

  [| doc: """The type of things that can be converted to JSON.""" |]
  export interface JsonSerialisable {
    method $this to-json -> string?
    method $protocol from-json: $value ^string?
  }

  [| doc: """The type of things that form a Semigroup.""" |]
  export interface Semigroup {
    method $this + $that
  }

  [| doc: """The type of things that form a Monoid.""" |]
  export interface Monoid {
    need Semigroup
    method $this empty
  }

  [| doc: """The type of things that can be mapped over.""" |]
  export interface Mappable {
    method $this map: $transformation
  }

  [| doc: """The type of things that can be applied as functions.""" |]
  export interface Applicative {
    need Mappable
    method $this of: $value
    method $this apply-to: $a-mappable
    method $this <*> $a-mappable => $this apply-to: $a-mappable
  }

  [| doc: """The type of things that can be chained.""" |]
  export interface Chainable {
    need Applicative
    method $this chain: $transformation
    method $this >>= $transformation => $this chain: $transformation
  }

  # -- Basic data types ------------------------------------------------
  export data Ordering = Less | Equal | Greater

  
  # -- Boolean ---------------------------------------------------------
  # implicitly `data Boolean = true | false`

  implement Equality for Boolean {
    method $a == $b => ffi "_a === _b"
  }

  implement Ordered for Boolean {
    method $a compare-to: $b => case $a, $b of
    | true, false => Less
    | false, true => Greater
    | _           => Equal
  }

  implement Representable for Boolean {
    method $a show => ffi "_a.toString()"
  }

  implement Bounded for Boolean {
    method $a upper-bound => true
    method $a lower-bound => false
  }

  implement Enumerable for Boolean {
    method $a successor => case $a of
                           | false => true
    method $a predecessor => case $a of
                             | true => false
  }

  implement JsonSerialisable for Boolean {
    method $a to-json => ffi "JSON.stringify(_a)"
    method $protocol from-json: $text -> boolean? => ffi "JSON.parse(_text)"
  }

  export $a ^boolean? && $b ^boolean? => ffi "_a && _b"

  export $a ^boolean? || $b ^boolean? => ffi "_a || _b"

  export not($a ^boolean?) => ffi "!_a"

  export $a ^boolean? negate => ffi "!_a"

  export $test ^boolean? then: $consequent else: $alternate =>
  | test      => consequent()
  | otherwise => alternate()



  # -- Number ----------------------------------------------------------
  implement Equality for Number {
    method $this == $that => ffi "_this === _that"
    method $this =/= $that => ffi "_this !== _that"
  }

  implement Ordered for Number {
    method $this compare-to: $that ^number? => 
         | ($this < $that) => Less
         | ($this > $that) => Greater
         | otherwise       => Equal

    method $this <  $that ^number? => ffi "_this < _that"
    method $this >  $that ^number? => ffi "_this > _that"
    method $this <= $that ^number? => ffi "_this <= _that"
    method $this >= $that ^number? => ffi "_this >= _that"
  }

  implement Representable for Number {
    method $this show => ffi "_this.toString()"
  }

  implement Bounded for Number {
    method $this upper-bound => ffi "_this.MIN_VALUE"
    method $this lower-bound => ffi "_this.MIN_VALUE"
  }

  implement Enumerable for Number {
    method $this successor => ffi "_this + 1"
    method $this predecessor => ffi "_this - 1"
  }

  implement JsonSerialisable for Number {
    method $this to-json => ffi "JSON.stringify(_this)"
    method $protocol from-json: $value -> number? => ffi "JSON.parse(value)"
  }

  implement Semigroup for Number {
    method $this + $that ^number? => ffi "_this + _that"
  }

  implement Monoid for Number {
    method $this empty => 0
  }

  export $this ^number? - $that ^number? => ffi "_this - _that"

  export $this ^number? * $that ^number? => ffi "_this * _that"

  export $this ^number? / $that ^number? => ffi "_this / _that" # "

  export $this ^number? modulus: $that ^number? => ffi "_this % _that"

  export $this ^number? absolute => ffi "Math.abs(_this)"

  export $this ^number? floor => ffi "Math.floor(_this)"

  export $this ^number? ceil => ffi "Math.ceil(_this)"

  export $this ^number? round => ffi "Math.round(_this)"


  export $this ^number? square-root => ffi "Math.sqrt(_this)"

  export $this ^number? divided-by: $that ^number? => $quotient - $quotient floor
                                                      where 
                                                        $quotient = $this / $that

  export $this ^number? is-even? => ($this modulus: $that) == 0
  export $this ^number? is-odd? => ($this modulus: $that) =/= 0

  export $this ^number? acos => ffi "Math.acos(_this)"
  export $this ^number? asin => ffi "Math.asin(_this)"
  export $this ^number? atan => ffi "Math.atan(_this)"
  export $this ^number? cos => ffi "Math.cos(_this)"
  export $this ^number? exp => ffi "Math.exp(_this)"
  export $this ^number? log => ffi "Math.log(_this)"
  export $this ^number? pow => ffi "Math.pow(_this)"
  export $this ^number? sin => ffi "Math.sin(_this)"
  export $this ^number? tan => ffi "Math.tan(_this)"
  
  # Constants
  export $this PI => ffi "Math.PI"
  

  # -- Strings ---------------------------------------------------------
  # built-in `String ~= [Char]`
  implement Equality for String {
    method $this == $that => ffi "_this === _that"
  }

  implement Representable for String {
    method $this show => ffi "_this"
  }

  implement Semigroup for String {
    method $this + $that ^string? => ffi "_this + _that"
  }

  implement Monoid for String {
    method $this empty => ""
  }

  # TODO: use a Character class to represent JS's conventional 1-length strings
  
  export $this ^string? upcase     => ffi "_this.toUpperCase()"
  export $this ^string? downcase   => ffi "_this.toLowerCase()"
  export $this ^string? trim       => ffi "_this.trim()"
  export $this ^string? trim-left  => ffi "_this.trimLeft()"
  export $this ^string? trim-right => ffi "_this.trimRight()"


  # -- Maybe -----------------------------------------------------------
  export data Maybe = Nothing | Just(_)

  implement Equality for Maybe {
    method $this ^maybe? == $that ^maybe? => case $this, $that of
                                             | Nothing, Nothing   => true
                                             | Just($a), Just($b) => $a == $b
                                             | _, _               => false
  }

  implement Representable for Maybe {
    method $this show => case $this of
                         | Nothing  => "Nothing"
                         | Just($a) => "Just(" + $a show + ")"
  }

  implement Semigroup for Maybe {
    method $this + $that => case $this, $that of
                            | Just($a), Just($b) => ($a + $b) Just
                            | _, _               => Nothing
  }

  implement Monoid for Maybe {
    method $this empty => Nothing
  }

  implement Mappable for Maybe {
    method $this map: $f => case $this of
                            | Nothing  => Nothing
                            | Just($a) => $f($a) Just
  }

  implement Applicative for Maybe {
    method $protocol of: $value => value Just
    method $this apply-to: $that => case $this of
                                    | Nothing  => $that
                                    | Just($f) => $that map: $f
  }

  implement Chainable for Maybe {
    method $this chain: $f => case $this of
                              | Nothing  => Nothing
                              | Just($a) => $f($a)
  }

  # -- Either ----------------------------------------------------------
  export data Either = Failure(_) | Success(_)


  # -- Function --------------------------------------------------------
  export $a identity => $a
  export $a constant => $b => $a
  export $f ->> $g => $a => $f($g($a))
  export $f <<- $g => $a => $g($f($a))
  export $f flip => $a $b => $f($b, $a)


  # -- Lists -----------------------------------------------------------
  export data List = Nil | _ :: _ ^list?
 
  export $xs filter: $f => case $xs of
    | Nil         => Nil
    | $x :: $rest => if $f($x) then $x :: $rest filter: $f
                               else $rest filter: $f

  export $xs first => case $xs of
    | Nil     => Nothing
    | $a :: _ => $a Just

  export $xs first! => case $xs of
    | $a :: _ => $a

  export $xs rest => case $xs of
    | Nil        => Nothing
    | _ :: $rest => $rest

  export $xs last => case $xs of
    | Nil        => Nothing
    | $a :: Nil  => a Just
    | _ :: $rest => $rest last

  export $xs last! => case $xs of
    | $a :: Nil  => $a
    | _ :: $rest => $rest last!

  export $xs is-empty? => case $xs of
    | Nil    => true
    | _ :: _ => false

  export $xs ^list? fold: $f from: $b => ffi "(function() {
    while (true) {
      if (_xs.$$ctag === 'Nil')  return _b
      if (_xs.$$ctag !== '::')  throw new TypeError('Not a List.')
      var v = _xs.$0
      _b = _f(_b, v)
      _xs = _xs.$1
    }
  })()"

  export $xs reverse => $xs fold: (_ :: _) flip from: Nil

  export $xs fold-right: $f from: $b => $xs reverse fold: $f from: $b

  export $xs length => $xs fold: ($a _ => $a + 1) from: 0


}
