module Phemme.Data.Number {

  import Phemme.Protocols
  import Phemme.Core

  implement Equality for Number {
    method $this === $that => ffi "$this === $that"
    method $this =/= $that => ffi "$this !== $that"
  }

  implement Ordered for Number {
    method $this compare-to: $that ^Number? =>
      | ($this < $that) => Less
      | ($this > $that) => Greater
      | otherwise       => Equal

    method $this < $that ^Number? => ffi "$this < $that"
    method $this > $that ^Number? => ffi "$this > $that"
    method $this <= $that ^Number? => ffi "$this <= $that"
    method $this >= $that ^Number? => ffi "$this >= $that"
  }

  implement Representable for Number {
    method $this show => ffi "$this.toString()"
  }

  implement Bounded for Number {
    method $this upper-bound => ffi "$this.MAX_VALUE"
    method $this lower-bound => ffi "$this.MIN_VALUE"
  }

  implement Enumerable for Number {
    method $this successor => ffi "$this + 1"
    method $this predecessor => ffi "$this - 1"
  }

  implement Semigroup for Number {
    method $this + $that ^Number? => ffi "$this + $that"
  }

  implement Monoid for Number {
    method $this empty => 0
  }

  export $this ^Number? - $that ^Number? => ffi "$this - $that"
  export $this ^Number? * $that ^Number? => ffi "$this * $that"
  export $this ^Number? / $that ^Number? => ffi "$this / $that"
  export $this ^Number? modulus: $that ^Number? => ffi "$this % $that"
  export $this ^Number? absolute => ffi "Math.abs($this)"
  export $this ^Number? floor => ffi "Math.floor($this)"
  export $this ^Number? ceil => ffi "Math.ceil($this)"
  export $this ^Number? round => ffi "Math.round($this)"
  export $this ^Number? square-root => ffi "Math.round($this)"
  export $this ^Number? divided-by: $that ^Number? => $quotient - $quotient floor
                                                      where
                                                        $quotient = $this / $that
  export $this ^Number? is-even? => ($this modulus: $that) === 0
  export $this ^Number? is-odd? => ($this modulus: $that) =/= 0

  export $this ^Number? acos => ffi "Math.acos($this)"
  export $this ^Number? asin => ffi "Math.asin($this)"
  export $this ^Number? atan => ffi "Math.atan($this)"
  export $this ^Number? cos => ffi "Math.cos($this)"
  export $this ^Number? exp => ffi "Math.exp($this)"
  export $this ^Number? log => ffi "Math.log($this)"
  export $this ^Number? pow => ffi "Math.pow($this)"
  export $this ^Number? sin => ffi "Math.sin($this)"
  export $this ^Number? tan => ffi "Math.tan($this)"
  
  export $this PI => ffi "Math.PI"

}
