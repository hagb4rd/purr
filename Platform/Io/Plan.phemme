module Io.Plan {
  import Phemme.Core
  import Data.Function
  import Data.String
  import Io.Task

  # This module provides a way to construct a plan about how I/O should be
  # dealt with. You declare what you want to do, potentially compose plans
  # as much as you want, then feed the plan to a Machine so it gets executed
  # for effects
  export
  data Plan = Halt
            | Fail: $reason
            | Emit: $value ^Semigroup? Then: _ ^Plan?
            | Await: $resource Then: _ ^Function? Fallback: _ ^Plan?

  export
  data Resource = { acquire ^Function?  # Unit → Task[Error, R]
                  , release ^Function?  # R → Task[Error, Unit]
                  , step ^Function?     # R → Task[Error, A]
                  }

  let $f force => $f()

  export $plan to-task: $input => 
    task: $next => $input go: $plan
      where $xs go: $p => match $p {
        | Halt                            => $next($xs Yield)
        | Fail: $e                        => $next($e Throw)
        | Emit: $ys Then: $t              => ($xs + $ys) go: $t
        | Await: $r Then: $c Fallback: $t => let $res = $r acquire force
                                             in do {
                                               $data <- $r step <| $res;
                                               $x <- match $data {
                                                 | Nothing  => $t to-task: $xs
                                                 | Just($a) => $c($a) to-task: $xs
                                               };
                                               $r release <| $res;
                                               return $x
                                             } run: @Yield ->> $next
      }

  export $plan to-task => $plan to-task: []

  implement Functor for Plan {
    method $p map: $f => ($p \/ halt) 
  }

  implement Applicative for Plan {
    method _ of: $v => $v emit
    method _ apply-to: _ => Unit
  }

  implement Chainable for Plan {
    method $p chain: $f => match $p {
      | Halt                             => $p
      | Fail: _                          => $p
      | Emit: $v Then: $t                => Emit: $v Then: $t + $f($v)
      | Await: $r Then: $c Fallback: $fb => Await: $r
                                            Then: ($v => let $t = $c($v)
                                                         in match $t {
                                                           | Halt => $f($v)
                                                           | _    => $t >>= $f
                                                         })
                                            Fallback: $fb >>= $f
    }
  }

  implement Semigroup for Plan {
    method $p + $p2 ^Plan? => match $p {
      | Halt                            => $p2
      | Fail: $reason                   => $p
      | Emit: $xs Then: $t              => Emit: $xs Then: $t + $p2
      | Await: $r Then: $c Fallback: $t => Await: $r Then: $c ->> (_ + $p2) Fallback: $t + $p2
    }
      
  }

  export $r await => Await: $r Then: @halt Fallback: halt
  export $r await-or: $fb => Await: $r Then: @halt Fallback: $fb
  export $x emit => Emit: $x Then: halt
  export $x fail => Fail: $x
  export halt => Halt
}

