module Concurrency.Async {
  import Phemme.Core
  import Data.Task
  import Data.List
  import Data.Vector
  import Control.Monad

  export _ ~ _ => Unit

  export $xs ^List? sequentially => $xs sequence-with: Task

  export $xs ^List? parallel =>
    task: ffi """
    (function($next) {
      var xs       = $self.$listToArray($xs)
      var len      = xs.length
      var result   = new Array(len)
      var resolved = false

      xs.forEach(runComputation)

      function runComputation(task, i) {
        $self['run:recover:'](function Success(value) {
          if (resolved)  return
          result[i] = value
          len = len - 1
          if (len === 0) {
            resolved = true
            $next($self.Success($self.Vector().$make(result)))
          }
        }, function Failure(error) {
          if (resolved)  return
          resolved = true
          $next($self.Failure(error))
        })
      }
    })"""

  export $t1 ^Task? or: $t2 ^Task? =>
    task: ffi """
    (function($next) {
      var resolved = false
      var a = $self['run:recover:']($t1, succeed($t1), fail($t1))
      var b = $self['run:recover:']($t2, succeed($t2), fail($t2))

      return [a, b]

      function succeed(x){ return function(v) { transition(x, $self.Success(v)) }}
      function fail(x){ return function(e)    { transition(x, $self.Failure(e)) }}
      function transition(x, v) {
        if (!resolved) {
          resolved = true
          if ($t1 !== x)  $t1.$$1(a)
          if ($t2 !== x)  $t2.$$1(b)
          $next(v)
        }
      }
    })"""
    cleanup: $state => case $t1, $t2 of
      | _ Cleanup: $c1, _ Cleanup: $c2 => $c1(ffi "$state[0]") ~ $c2(ffi "$state[1]")

  export $xs ^List? choose-first => $xs fold: _ or: _ from: never

  export $xs ^List? try-all =>
    task: ffi """
    (function($next) {
      var xs = $self.$listToArray($xs)
      var resolved = false
      var pending  = xs.length
      var failures = new Array(pending)

      var ys = xs.map(function(x, i) {
        return $self['run:recover:'](x, succeed(x, i), accumulateFailure(i))
      })

      function succeed(x, i){ return function(value) {
        resolved = true
        xs.forEach(function(y){
          if (y !== x)  y.$$1(ys[i])
        })
        $next($self.Success(value))
      }}

      function accumulateFailure(index){ return function(error) {
        if (resolved)  return
        failures[index] = error
        pending = pending - 1
        if (pending === 0)
          $next($self.Failure($self.Vector().$make(failures)))
      }}
    })"""

  implement BooleanAlgebra for Task {
    method $this || $that ^Task? => $this or: $that
    method $this && $that ^Task? => [$this, $that] parallel
    method not($this) =>
      task: $next => $this run: ($v => $next($v Failure))
                           recover: ($e => $next($e Success))
  }


}
