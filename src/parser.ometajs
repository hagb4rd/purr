// Copyright (c) 2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/**
 * The parser for the Phemme language.
 *
 * @module phemme/parser
 */

/**
 * Reserved symbols in this language.
 */
var reserved = [ ':'  // Method parameter
               , '->'  // Contract
               , '_'  // Partial / Wildcard
               , '=>' // Function definition
               , '|'  // Case separators
               , '<-' // Do binding
               , '<|', '|>'  // pipes
               // Protocols
               , 'interface'
               , 'implement'
               , 'for'
               , 'method'
               , 'need'
               , 'derivation'
               // Data structures
               , 'data'
               , 'match'
               // Modules
               , 'module'
               , 'use'
               , 'import'
               , 'with'
               , 'as'
               // Scoping & others
               , 'let'
               , 'in'
               , 'where'
               , 'export'
               , 'ffi'
               , 'true'
               , 'false'
               , 'if'
               , 'then'
               , 'else'
               , 'do'
               , 'return'
               ]

/**
 * Verifies if a name can be used.
 */
function isValid(name) {
  return reserved.indexOf(name) === -1
}

function kwId(xss) {
  return [#Id, xss.map(function(xs){ return xs[0][1] }).join('')]
}

function kwArgs(xss) {
  return xss.map(function(xs){ return xs[1] })
}

function kwCont(xss) {
  return xss.map(function(xs){ return xs[2] })
}

ometa Parser {
  // Lexical structure
  space   = ^space | comment,
  comment = fromTo('#', '\n'),
  ws      = space*,
  symbol  = ~(letter | digit | space
             | '$' | '@' | '^' | ';' | ',' | '.' | ':' | '[' | ']' | '{' | '}' | '(' | ')') char,
  eof     = ~char,
  kw :xs  = seq(xs) ~(letter | digit | symbol | ':'),

  // Identifiers
  idStart    = letter,
  idRest     = letter | digit | symbol,
  symbolChar = symbol | ':',
  varName    = '$' <idStart idRest*>:a ~':'           -> [#Id, a],
  uId        = <idStart idRest*>:a                    -> [#Id, a],
  identifier = <idStart idRest*>:a ~':' ?(isValid(a)) -> [#Id, a],
  keyword    = <idStart idRest*>:a ':'                -> [#Id, a + ':'],
  symbols    = <symbolChar+>:a          ?(isValid(a)) -> [#Id, a],
  extendedId = symbols
             | keyword+:ks  -> [#Id, ks.map(function(a){ return a[1] }).join('')]
             | identifier,
  namespace  = identifier:a ('.' identifier)*:bs -> [#Id, [a].concat(bs).reduce(function(r,a){
                                                            return r? r + '.' + a[1] : a[1]
                                                          }, '')],

  // Values
  bool = kw('true'):a  -> [#Bool, true]
       | kw('false'):a -> [#Bool, false],

  digits = <digit+>:a -> Number(a),
  number = digits:a ('.' digits:b)? -> [#Num, a, b || 0],
  
  stringEscape     = '\\' ( 'b' -> '\b'
                          | 'f' -> '\f'
                          | 'n' -> '\n'
                          | 'r' -> '\r'
                          | 't' -> '\t'
                          | char),
  stringChar       = (stringEscape | (~seq('"') char)):a -> a,
  unescapableChars = ~seq('"""') char,
  string           = seq('"""') <unescapableChars*>:as seq('"""') -> [#Str, as]
                   | '"' (stringChar)*:as '"'                     -> [#Str, as.join('')],

  vector = '[' ws expr:hd (ws ',' ws expr)*:tl ws ']' -> [#List, [hd].concat(tl)]
         | '[' ws ']'                                 -> [#List, []],

  map = '{' ws mapExpr:hd (ws ',' ws mapExpr)*:tl ws '}' -> [#Map, [hd].concat(tl)]
      | '{' ws '}'                                       -> [#Map, []],

  mapExpr = uId:a ws "=>" ws expr:b    -> [#MapField, a, b]
          | string:a ws "=>" ws expr:b -> [#MapField, a, b],
 
  set = '#' vector:xs -> [#Set, xs[1]],

  value = number
        | string
        | bool
        | vector
        | map
        | set,

  // Patterns
  pattern = keywordPattern
          | binaryPattern
          | unaryPattern,

  spKeywordPatt  = keywordArg:k (ws keywordArg)*:ks                          -> (function(kws) {
                                                                                  return [kwId(kws), [[#Id, '_']].concat(kwArgs(kws)), [[#Nil]].concat(kwCont(kws))]
                                                                                }([k].concat(ks))),
  keywordPattern = keywordLeading:bs (ws keywordArg)+:ks                     -> [kwId(ks), [bs[0]].concat(kwArgs(ks)), [bs[1]].concat(kwCont(ks))],
  unaryPattern   = pattId:a ws preC:c1 ws identifier:b                       -> [b, [a], [c1]]
                 | identifier:a ws '(' ws pattId:b ws preC:c1 ws ')'         -> [a, [b], [c1]]
                 | preC:c1 ws identifier:a                                   -> [a, [[#Id, '_']], [c1]],
  binaryPattern  = pattId:a ws preC:c1 ws symbols:b ws pattId:c ws preC:c2 -> [b, [a, c], [c1, c2]],

  keywordLeading = (pattId:a ws preC:c1 -> [a, c1])?:xs -> xs || [[#Id, '_'], [#Nil]],
  keywordArg     = keyword:k ws pattId:n ws preC:c -> [k, n, c],
  pattId = varName:a -> a
         | '_'       -> [#Id, '_'],

  preC = ('^' contractExpr:e)? -> e || [#Nil],
  posC = ("->" ws contractExpr:e)? -> e || [#Nil],
  contractExpr = extendedId:id -> [#Member, [#Var, 'self'], id],

  // Declarations
  declaration = module
              | decorator
              | iface
              | implem
              | adt
              | importDecl
              | ffiStmt
              | useStmt
              | exportStmt
              | letStmt,

  exportStmt = kw('export') ws
             ( pattern:p ws fnBody:e -> [p[0], [#Let, p[0], [#Fn, p, e]]]
             | adt:a                 -> [a[1], a, #Unpack, [[#Id, a[1][1] + '?']]]
             | iface:a               -> [a[1], a, #Unpack, [[#Id, a[1][1] + '?']]]
             | module:a              -> [a[1][0], a]
             | extendedId:a          -> [a, [#Empty]]
             ):exp -> [#Multi,
                       exp[1],
                       [#Export, exp[0], exp[2]]].concat(
                         (exp[3] || []).map(function(a){ 
                           return [#Export, a, null] })
                       ),
  
  ffiStmt = kw('ffi') ws string:a -> [#FFIStmt, a],

  letStmt = kw('let') ws pattern:p ws fnBody:e -> [#Let, p[0], [#Fn, p, e]],

  useStmt = kw('use') ws expr:e -> [#Use, e],

  module = kw('module') ws mparms:p ws '{' (ws declaration)*:xs ws '}' -> [#Mod, p, xs, false],
  mparms = namespace:ns (ws keywordArg)*:ks -> (function(i, xs, cs) {
                                                 if (i[1]) ns[1] = ns[1] + ':' + i[1]
                                                 return [ns, xs, cs]
                                               }(kwId(ks), kwArgs(ks), kwCont(ks))),

  iface = kw('interface') ws identifier:a 
            ws '{' (ws ifaceDecl)*:xs ws '}' 
        -> [#IFace, a, xs],

  ifaceDecl  = needDecl
             | methodDecl,
  needDecl   = kw('need') ws expr:e -> [#INeed, e],
  methodDecl = kw('method') ws pattern:p ws fnBody:e -> [#DMeth, p, [#Fn, p, e]]
             | kw('method') ws pattern:p ws posC:c   -> [#IMeth, c].concat(p),

  implem = kw('implement') ws expr:a ws kw('for') ws expr:b
             ws '{' (ws implDecl)*:xs ws '}' -> [#Impl, a, b, xs],
  implDecl = methodImpl,
  methodImpl = kw('method') ws pattern:p ws fnBody:e -> [#Meth, p[0], [#Fn, p, e]],

  adt = kw('data') ws identifier:id ws '=' ws struct:xs  -> [#Struct, id, xs]
      | kw('data') ws identifier:id ws '=' ws adtPatterns:xs -> [#Data, id, xs],
  adtPatt = spKeywordPatt:p  -> [#DataCtor, [#Kw].concat(p)]
          | binaryPattern:p  -> [#DataCtor, [#Bin].concat(p)]
          | unaryPattern:p   -> [#DataCtor, [#Un].concat(p)]
          | identifier:a     -> [#DataCtor, [#Val, a, [], []]],
  adtPatterns = adtPatt:a (ws '|' ws adtPatt)*:as -> [a].concat(as),

  struct = '{' ws listOf(#structField, ','):xs ws '}' -> xs,
  structField = uId:a ws preC:c1-> [#StructF, a, c1],

  decorator = "[|" ws expr:a ws "|]" ws
            ( module:m                  -> [#Deco, a, m[1][0], m]
            | adt:b                     -> [#Deco, a, b[1], b]
            | iface:b                   -> [#Deco, a, b[1], b]
            | letStmt:b                 -> [#Deco, a, b[1], b]
            | exportStmt:b              -> [#Deco, a, b[1][1], b]
            | decorator:b               -> [#Deco, a, b[2], b]
            ),

  importDecl = kw('import') ws namespace:p
                 (ws kw('with') (ws keywordApp)+:ks)?
                 (ws kw('as') ws identifier:n)?
             -> [#Import, p
                 , ks? [#ImpKw, kwId(ks), kwArgs(ks)] : [#Nil]
                 , n || [#Nil]],

  // Pattern matching
  matchCase  = keywordCase:k (ws keywordCase)*:ks         -> [#CaseKw, kwId([k].concat(ks)), kwArgs([k].concat(ks))]
             | matchCase2,
  matchCase2 = matchCase2:x ws symbols:s ws matchCase3:y -> [#CaseBin, s, [x, y]]
             | matchCase3,
  matchCase3 = matchCase3:a ws identifier:b              -> [#CaseUn, b, a]
             | matchCase4,
  matchCase4 = '_'                                       -> [#CaseAny]
             | varName:a                                 -> [#CaseVar, a]
             | identifier:a ws '(' ws matchCase:b ws ')' -> [#CaseUn, a, b]
             | identifier:a                              -> [#CaseId, a]
             | number:a                                  -> [#CaseVal, a]
             | bool:a                                    -> [#CaseVal, a]
             | string:a                                  -> [#CaseVal, a]
             | '(' ws matchCase:a ws ')'                 -> a,

  keywordCase = keyword:k ws matchCase2:x -> [k, x],
  caseExpr = kw('match') ws listOf(#expr, ','):es ws '{' ws (ws casePatt)+:xs ws '}' -> [#Case, es, xs],
  casePatt = '|' ws listOf(#matchCase, ','):cs ws "=>" ws expr:b                     -> [#CPatt, cs, b],

  // Expressions
  letExpr   = kw('let') ws bindingList:xs ws kw('in') ws expr:e -> [#Bind, xs, e],
  ifExpr    = kw('if') ws expr:a ws kw('then') ws expr:b ws kw('else') ws expr:c -> [#IfExpr, a, b, c],
  whereExpr = appExpr:e ws kw('where') ws bindingList:xs      -> [#Bind, xs, e],

  doExpr = kw('do') ws '{' ws listOf(#doCase, ';'):xs ws '}' -> [#Do, xs],
  doTailAction = expr:e -> [#DoAct, [#Id, '_'], e],
  doAction = pattId:a ws "<-" ws expr:e -> [#DoAct, a, e]
           | doTailAction,
  doTailPure = kw('return') ws expr:e -> [#DoRet, [#Id, '_'], e],
  doPure = pattId:a ws "<-" ws kw('return') ws expr:e -> [#DoRet, a, e]
         | doTailPure,
  doCase = doPure
         | doAction,

  expr = letExpr
       | ifExpr
       | whereExpr,

  whereExpr = whereExpr
            | fpipeExpr,

  fpipeExpr = fpipeExpr:a ws "|>" ws bpipeExpr:b -> [#FnApp, b, [a]]
            | bpipeExpr,

  bpipeExpr = bpipeExpr:a ws "<|" ws appExpr:b -> [#FnApp, a, [b]]
            | appExpr,

  appExpr = keywordExpr
          | binaryExpr,


  nsMember = ('@' identifier:a ('.' identifier)*:xs -> [[#Member, [#Var, 'self'], a], xs]
             | varName:a ('.' identifier)*:xs       -> [[#Var, a[1]], xs]
             ):ys -> ys[1].reduce(function(bs, b) {
                       return [#Member, bs, b]
                     }, ys[0]),

  nsKw = nsMember:n '.' keywordApp:p -> [n, p]
       | keywordApp:p                -> [[#Var, 'self'], p],
  nsSym = nsMember:n '.' symbols:s -> [n, s]
        | symbols:s                -> [[#Var, 'self'], s],

  keywordExpr = binaryExpr?:a ws nsKw:x (ws keywordApp)*:as -> (function() {
    var kws = [x[1]].concat(as)
    return [#App, x[0], kwId(kws), [a || x[0]].concat(kwArgs(kws))]
  }()),
  binaryExpr  = binaryExpr:a ws nsSym:s ws unaryExpr:b -> [#App, s[0], s[1], [a, b]]
              | unaryExpr,
  unaryExpr   = unaryExpr:a ws identifier:i            -> [#App, [#Var, 'self'], i, [a]]
              | postfixExpr,
  postfixExpr = postfixExpr:a ws '.' ws extendedId:i                 -> [#Member, a, i]
              | postfixExpr:a ws '(' ws listOf(#expr, ','):bs ws ')' -> [#FnApp, a, bs]
              | postfixExpr:a ws map:m                               -> [#New, a, m]
              | primaryExpr,
  primaryExpr = ffi
              | value
              | caseExpr
              | doExpr
              | lambda
              | identifier:a         -> [#App, [#Var, 'self'], a, [[#Var, 'self']]]
              | '@' extendedId:i     -> [#Member, [#Var, 'self'], i]
              | varName:a            -> [#Var, a[1]]
              | '_'                  -> [#Partial]
              | '(' ws expr:a ws ')' -> a,

  keywordApp = keyword:k ws binaryExpr:v -> [k, v],

  ffi = kw('ffi') ws string:a -> [#FFI, a],

  lambda = (ws pattId)*:as ws fnBody:b -> [#Lambda, as, b],

  bindingList = bindingCase:x (ws '|' ws bindingCase)*:xs -> [x].concat(xs),
  bindingCase = '$' identifier:a ws '=' ws expr:e     -> [#VarBind, a, e]
              | pattern:p ws fnBody:e   -> [#Let, p[0], [#Fn, p, e]],

  fnBody = posC:c ws "=>" ws ( condExpr:e -> [e, c]
                             | expr:e     -> [[#Ret, e], c]
                             ),

  condExpr = condCase:x (ws condCase)*:xs -> [#Cond, [x].concat(xs)],
  condCase = '|' ws expr:t ws "=>" ws expr:e -> [#CondCase, t, e],

  // Program
  program = ws module:m ws eof -> { m[3] = true; [#Program, m[1][0], m] }
}
