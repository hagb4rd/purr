// Copyright (c) 2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/**
 * The parser for the Phemme language.
 *
 * @module phemme/parser
 */

/**
 * Reserved symbols in this language.
 */
var reserved = [ ':'  // Method parameter
               , '@'  // Self sends
               , '^'  // Contract
               , '_'  // Partial / Wildcard
               , '=>' // Function definition
               , '|'  // Case separators
               // Protocols
               , 'interface'
               , 'implement'
               , 'for'
               , 'method'
               , 'need'
               // Data structures
               , 'data'
               , 'struct'
               , 'field'
               , 'case'
               , 'of'
               // Modules
               , 'module'
               , 'use'
               // Scoping & others
               , 'let'
               , 'export'
               , 'ffi'
               , 'true'
               , 'false'
               ]

/**
 * Verifies if a name can be used.
 */
function isValid(name) {
  return reserved.indexOf(name) === -1
}

function kwId(xss) {
  return [#Id, xss.map(function(xs){ return xs[0][1] }).join('')]
}

function kwArgs(xss) {
  return xss.map(function(xs){ return xs[1] })
}

ometa Parser {
  // Lexical structure
  space   = ^space | comment,
  comment = fromTo('#', '\n'),
  ws      = space*,
  symbol  = ~(letter | digit | space
             | '$' | ';' | ',' | '.' | ':' | '[' | ']' | '{' | '}' | '(' | ')') char,
  eof     = ~char,
  kw :xs  = seq(xs) ~(letter | digit | symbol | ':'),

  // Identifiers
  idStart    = letter,
  idRest     = letter | digit | symbol,
  symbolChar = symbol | ':',
  identifier = <idStart idRest*>:a ~':' ?(isValid(a)) -> [#Id, a],
  keyword    = <idStart idRest*>:a ':'                -> [#Id, a + ':'],
  symbols    = <symbolChar+>:a          ?(isValid(a)) -> [#Id, a],
  extendedId = symbols
             | keyword+:ks  -> [#Id, ks.map(function(a){ return a[1] }).join('')]
             | identifier,

  // Values
  bool = kw('true'):a  -> [#Bool, true]
       | kw('false'):a -> [#Bool, false],

  digits = <digit+>:a -> Number(a),
  number = digits:a ('.' digits:b)? -> [#Num, a, b || 0],
  
  stringEscape     = '\\' '"',
  stringChar       = (stringEscape | (~seq('"') char)):a -> a,
  unescapableChars = ~seq('"""') char,
  string           = seq('"""') <unescapableChars*>:as seq('"""') -> [#Str, as]
                   | '"' <stringChar*>:as '"'                     -> [#Str, as],

  vector = '[' ws expr:hd (ws ',' ws expr)*:tl ws ']' -> [#Vec, [hd].concat(tl)]
         | '[' ws ']'                                 -> [#Vec, []],

  map = '{' ws mapExpr:hd (ws ',' ws mapExpr)*:tl ws '}' -> [#Map, [hd].concat(tl)]
      | '{' ws '}'                                       -> [#Map, []],

  set = '#' vector:xs -> [#Set, xs[1]],

  value = number
        | string
        | bool
        | vector
        | map
        | set,

  // Patterns
  pattern = keywordPattern
          | binaryPattern
          | unaryPattern,

  keywordPattern = identifier:a (ws keywordArg)+:ks          -> [kwId(ks), [a].concat(kwArgs(ks))],
  unaryPattern   = identifier:a ws identifier:b               -> [b, [a]]
                 | identifier:a ws '(' ws identifier:b ws ')' -> [a, [b]],
  binaryPattern  = identifier:a ws symbols:b ws identifier:c -> [b, [a, c]],

  keywordArg     = keyword:k ws identifier:n -> [k, n],

  // Declarations
  declaration = module
              | iface
              | implem
              | adt
              | useStmt
              | exportStmt
              | letStmt,

  exportStmt = kw('export') ws pattern:p ws "=>" ws expr:e -> [#Multi
                                                              ,[#Let, p[0], [#Fn, p, e]]
                                                              ,[#Export, p[0]]],     
  letStmt = kw('let') ws pattern:p ws "=>" ws expr:e -> [#Let, p[0], [#Fn, p, e]],

  useStmt = kw('use') ws expr:e -> [#Use, e],

  module = kw('module') ws mparms:p ws '{' (ws declaration)*:xs ws '}' -> [#Mod, p, xs],
  mparms = (ws keywordArg)*:ks -> (function(i,xs) {
                                     return [i[1]? i : [#Id, 'default'], xs]
                                  }(kwId(ks), kwArgs(ks))),

  iface = kw('interface') ws identifier:a ws '{' (ws ifaceDecl)*:xs ws '}' -> [#IFace, a, xs],
  ifaceDecl  = needDecl
             | methodDecl,
  needDecl   = kw('need') ws expr:e -> [#INeed, e],
  methodDecl = kw('method') ws pattern:p ws "=>" ws expr:e -> [#DMeth, p, [#Fn, p, e]]
             | kw('method') ws pattern:p                   -> [#IMeth].concat(p),

  implem = kw('implement') ws expr:a ws kw('for') ws expr:b
             ws '{' (ws implDecl)*:xs ws '}' -> [#Impl, a, b, xs],
  implDecl = methodImpl,
  methodImpl = kw('method') ws pattern:p ws "=>" ws expr:e -> [#Meth, p[0], [#Fn, p, e]],

  adt = kw('data') ws identifier:id ws '=' ws adtPatterns:xs -> [#Data, id, xs],
  adtPatt = keywordPattern:p -> [#DataCtor, [#Kw].concat(p)]
          | binaryPattern:p  -> [#DataCtor, [#Bin].concat(p)]
          | unaryPattern:p   -> [#DataCtor, [#Un].concat(p)]
          | identifier:a     -> [#DataCtor, [#Val, a, []]],
  adtPatterns = adtPatt:a (ws '|' ws adtPatt)*:as -> [a].concat(as),

  // Pattern matching
  matchCase = matchValue
            | matchCtor
            | matchWildcard,

  matchValue = number:a -> [#CaseVal, a]
             | bool:a   -> [#CaseVal, a]
             | string:a -> [#CaseVal, a],

  matchCtor = binaryPattern:p  -> [#CaseBin].concat(p)
            | keywordPattern:p -> [#CaseKw].concat(p)
            | unaryPattern:p   -> [#CaseUn].concat(p)
            | identifier:a     -> [#CaseId, a],

  matchWildcard = '_' -> [#CaseAny],

  caseExpr = kw('case') ws expr:a ws kw('of') ws (ws casePatt)+:xs -> [#Case, a, xs],
  casePatt = '|' ws matchCase:a ws "=>" ws expr:b                  -> [#CPatt, a, b],

  // Expressions
  expr = keywordExpr
       | binaryExpr,

  keywordExpr = binaryExpr?:a (ws keywordApp)+:as        -> [#App, [#Var, 'self'], kwId(as), [a || [#Var, 'self']].concat(kwArgs(as))],
  binaryExpr  = binaryExpr:a ws symbols:s ws unaryExpr:b -> [#App, [#Var, 'self'], s, [a, b]]
              | unaryExpr,
  unaryExpr   = unaryExpr:a ws identifier:i              -> [#App, [#Var, 'self'], i, [a]]
              | postfixExpr,
  postfixExpr = postfixExpr:a ws '.' ws extendedId:i                 -> [#Member, a, i]
              | postfixExpr:a ws '(' ws listOf(#expr, ','):bs ws ')' -> [#FnApp, a, bs]
              | primaryExpr,
  primaryExpr = ffi
              | value
              | caseExpr
              | lambda
              | '@' ws identifier:a  -> [#App, [#Var, 'self'], a, [[#Var, 'self']]]
              | identifier:a         -> [#Var, a[1]]
              | '(' ws expr:a ws ')' -> a,

  keywordApp = keyword:k ws binaryExpr:v -> [k, v],

  ffi = kw('ffi') ws string:a -> [#FFI, a],

  lambda = (ws identifier)+:as ws "=>" ws expr:b -> [#Lambda, as, b],

  // Program
  program = ws module:m ws eof -> [#Program, m && m[1][0], m]
}
