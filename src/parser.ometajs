// Copyright (c) 2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/**
 * The parser for the Phemme language.
 *
 * @module phemme/parser
 */

/**
 * Reserved symbols in this language.
 */
var reserved = [ ':'  // Method parameter
               , '->'  // Contract
               , '_'  // Partial / Wildcard
               , '=>' // Function definition
               , '|'  // Case separators
               , '<|', '|>'  // pipes
               // Protocols
               , 'interface'
               , 'implement'
               , 'for'
               , 'method'
               , 'need'
               , 'derivation'
               // Data structures
               , 'data'
               , 'struct'
               , 'field'
               , 'case'
               , 'of'
               // Modules
               , 'module'
               , 'use'
               , 'import'
               , 'with'
               , 'as'
               // Scoping & others
               , 'let'
               , 'in'
               , 'where'
               , 'export'
               , 'ffi'
               , 'true'
               , 'false'
               , 'if'
               , 'then'
               , 'else'
               ]

/**
 * Verifies if a name can be used.
 */
function isValid(name) {
  return reserved.indexOf(name) === -1
}

function kwId(xss) {
  return [#Id, xss.map(function(xs){ return xs[0][1] }).join('')]
}

function kwArgs(xss) {
  return xss.map(function(xs){ return xs[1] })
}

function kwCont(xss) {
  return xss.map(function(xs){ return xs[2] })
}

ometa Parser {
  // Lexical structure
  space   = ^space | comment,
  comment = fromTo('#', '\n'),
  ws      = space*,
  symbol  = ~(letter | digit | space
             | '$' | '@' | '^' | ';' | ',' | '.' | ':' | '[' | ']' | '{' | '}' | '(' | ')') char,
  eof     = ~char,
  kw :xs  = seq(xs) ~(letter | digit | symbol | ':'),

  // Identifiers
  idStart    = letter,
  idRest     = letter | digit | symbol,
  symbolChar = symbol | ':',
  varName    = '$' <idStart idRest*>:a ~':'           -> [#Id, a],
  identifier = <idStart idRest*>:a ~':' ?(isValid(a)) -> [#Id, a],
  keyword    = <idStart idRest*>:a ':'                -> [#Id, a + ':'],
  symbols    = <symbolChar+>:a          ?(isValid(a)) -> [#Id, a],
  extendedId = symbols
             | keyword+:ks  -> [#Id, ks.map(function(a){ return a[1] }).join('')]
             | identifier,

  // Values
  bool = kw('true'):a  -> [#Bool, true]
       | kw('false'):a -> [#Bool, false],

  digits = <digit+>:a -> Number(a),
  number = digits:a ('.' digits:b)? -> [#Num, a, b || 0],
  
  stringEscape     = '\\' '"',
  stringChar       = (stringEscape | (~seq('"') char)):a -> a,
  unescapableChars = ~seq('"""') char,
  string           = seq('"""') <unescapableChars*>:as seq('"""') -> [#Str, as]
                   | '"' <stringChar*>:as '"'                     -> [#Str, as],

  vector = '[' ws expr:hd (ws ',' ws expr)*:tl ws ']' -> [#List, [hd].concat(tl)]
         | '[' ws ']'                                 -> [#List, []],

  map = '{' ws mapExpr:hd (ws ',' ws mapExpr)*:tl ws '}' -> [#Map, [hd].concat(tl)]
      | '{' ws '}'                                       -> [#Map, []],

  mapExpr = string:a ws "=>" ws expr:b -> [#MapField, a, b],
 
  set = '#' vector:xs -> [#Set, xs[1]],

  value = number
        | string
        | bool
        | vector
        | map
        | set,

  // Patterns
  pattern = keywordPattern
          | binaryPattern
          | unaryPattern,

  keywordPattern = pattId:a ws preC:c1 (ws keywordArg)+:ks                   -> [kwId(ks), [a].concat(kwArgs(ks)), [c1].concat(kwCont(ks))],
  unaryPattern   = pattId:a ws preC:c1 ws identifier:b                       -> [b, [a], [c1]]
                 | identifier:a ws '(' ws pattId:b ws preC:c1 ws ')'         -> [a, [b], [c1]],
  binaryPattern  = pattId:a ws preC:c1 ws symbols:b ws pattId:c ws preC:c2 -> [b, [a, c], [c1, c2]],

  keywordArg     = keyword:k ws pattId:n ws preC:c -> [k, n, c],
  pattId = varName:a -> a
         | '_'       -> [#Id, '_'],

  preC = ('^' contractExpr:e)? -> e || [#Nil],
  posC = ("->" ws contractExpr:e)? -> e || [#Nil],
  contractExpr = extendedId:id -> [#Member, [#Var, 'self'], id],

  // Declarations
  declaration = module
              | decorator
              | iface
              | implem
              | adt
              | importDecl
              | useStmt
              | exportStmt
              | letStmt,

  exportStmt = kw('export') ws
             ( pattern:p ws fnBody:e -> [p[0], [#Let, p[0], [#Fn, p, e]]]
             | adt:a                 -> [a[1], a, #Unpack]
             | iface:a               -> [a[1], a, #Unpack]
             | module:a              -> [a[1][0], a]
             | extendedId:a          -> [a, [#Empty]]
             ):exp -> [#Multi,
                       exp[1],
                       [#Export, exp[0], exp[2]]],
  
  letStmt = kw('let') ws pattern:p ws fnBody:e -> [#Let, p[0], [#Fn, p, e]],

  useStmt = kw('use') ws expr:e -> [#Use, e],

  module = kw('module') ws mparms:p ws '{' (ws declaration)*:xs ws '}' -> [#Mod, p, xs, false],
  mparms = (ws keywordArg)*:ks -> (function(i,xs, cs) {
                                     return [i[1]? i : [#Id, 'default'], xs, cs]
                                  }(kwId(ks), kwArgs(ks), kwCont(ks))),

  iface = kw('interface') ws identifier:a 
            ws '{' (ws ifaceDecl)*:xs ws '}' 
        -> [#IFace, a, xs],

  ifaceDecl  = needDecl
             | methodDecl,
  needDecl   = kw('need') ws expr:e -> [#INeed, e],
  methodDecl = kw('method') ws pattern:p ws fnBody:e -> [#DMeth, p, [#Fn, p, e]]
             | kw('method') ws pattern:p ws posC:c   -> [#IMeth, c].concat(p),

  implem = kw('implement') ws expr:a ws kw('for') ws expr:b
             ws '{' (ws implDecl)*:xs ws '}' -> [#Impl, a, b, xs],
  implDecl = methodImpl,
  methodImpl = kw('method') ws pattern:p ws fnBody:e -> [#Meth, p[0], [#Fn, p, e]],

  adt = kw('data') ws identifier:id ws '=' ws adtPatterns:xs -> [#Data, id, xs],
  adtPatt = keywordPattern:p -> [#DataCtor, [#Kw].concat(p)]
          | binaryPattern:p  -> [#DataCtor, [#Bin].concat(p)]
          | unaryPattern:p   -> [#DataCtor, [#Un].concat(p)]
          | identifier:a     -> [#DataCtor, [#Val, a, [], []]],
  adtPatterns = adtPatt:a (ws '|' ws adtPatt)*:as -> [a].concat(as),

  decorator = "[|" ws expr:a ws "|]" ws
            ( module:m                  -> [#Deco, a, m[1][0], m]
            | adt:b                     -> [#Deco, a, b[1], b]
            | iface:b                   -> [#Deco, a, b[1], b]
            | letStmt:b                 -> [#Deco, a, b[1], b]
            | exportStmt:b              -> [#Deco, a, b[1][1], b]
            | decorator:b               -> [#Deco, a, b[2], b]
            ),

  importDecl = kw('import') ws string:p
                 (ws kw('with') (ws keywordApp)+:ks)?
                 (ws kw('as') ws identifier:n)?
             -> [#Import, p
                 , ks? [#ImpKw, kwId(ks), kwArgs(ks)] : [#Nil]
                 , n || [#Nil]],

  // Pattern matching
  matchCase  = matchCase2:x (ws keywordCase)+:ks         -> [#CaseKw, kwId(ks), [x].concat(kwArgs(ks))]
             | matchCase2,
  matchCase2 = matchCase2:x ws symbols:s ws matchCase3:y -> [#CaseBin, s, [x, y]]
             | matchCase3,
  matchCase3 = matchCase3:a ws identifier:b              -> [#CaseUn, b, a]
             | matchCase4,
  matchCase4 = '_'                                       -> [#CaseAny]
             | '$' identifier:a                          -> [#CaseVar, a]
             | identifier:a ws '(' ws matchCase:b ws ')' -> [#CaseUn, a, b]
             | identifier:a                              -> [#CaseId, a]
             | number:a                                  -> [#CaseVal, a]
             | bool:a                                    -> [#CaseVal, a]
             | string:a                                  -> [#CaseVal, a]
             | '(' ws matchCase:a ws ')'                 -> a,

  keywordCase = keyword:k ws matchCase2:x -> [k, x],
  caseExpr = kw('case') ws listOf(#expr, ','):es ws kw('of') ws (ws casePatt)+:xs -> [#Case, es, xs],
  casePatt = '|' ws listOf(#matchCase, ','):cs ws "=>" ws expr:b                  -> [#CPatt, cs, b],

  // Expressions
  letExpr   = kw('let') ws bindingList:xs ws kw('in') ws expr:e -> [#Bind, xs, e],
  ifExpr    = kw('if') ws expr:a ws kw('then') ws expr:b ws kw('else') ws expr:c -> [#IfExpr, a, b, c],
  whereExpr = appExpr:e ws kw('where') ws bindingList:xs      -> [#Bind, xs, e],


  expr = letExpr
       | ifExpr
       | whereExpr,

  whereExpr = whereExpr
            | fpipeExpr,

  fpipeExpr = fpipeExpr:a ws "|>" ws bpipeExpr:b -> [#FnApp, b, [a]]
            | bpipeExpr,

  bpipeExpr = bpipeExpr:a ws "<|" ws appExpr:b -> [#FnApp, a, [b]]
            | appExpr,

  appExpr = keywordExpr
          | binaryExpr,

  keywordExpr = binaryExpr?:a (ws keywordApp)+:as        -> [#App, [#Var, 'self'], kwId(as), [a || [#Var, 'self']].concat(kwArgs(as))],
  binaryExpr  = binaryExpr:a ws symbols:s ws unaryExpr:b -> [#App, [#Var, 'self'], s, [a, b]]
              | unaryExpr,
  unaryExpr   = unaryExpr:a ws identifier:i              -> [#App, [#Var, 'self'], i, [a]]
              | postfixExpr,
  postfixExpr = postfixExpr:a ws '.' ws extendedId:i                 -> [#Member, a, i]
              | postfixExpr:a ws '(' ws listOf(#expr, ','):bs ws ')' -> [#FnApp, a, bs]
              | primaryExpr,
  primaryExpr = ffi
              | value
              | caseExpr
              | lambda
              | identifier:a         -> [#App, [#Var, 'self'], a, [[#Var, 'self']]]
              | '@' extendedId:i     -> [#Member, [#Var, 'self'], i]
              | varName:a            -> [#Var, a[1]]
              | '_'                  -> [#Partial]
              | '(' ws expr:a ws ')' -> a,

  keywordApp = keyword:k ws binaryExpr:v -> [k, v],

  ffi = kw('ffi') ws string:a -> [#FFI, a],

  lambda = (ws pattId)+:as ws fnBody:b -> [#Lambda, as, b],

  bindingList = bindingCase:x (ws '|' ws bindingCase)*:xs -> [x].concat(xs),
  bindingCase = '$' identifier:a ws '=' ws expr:e     -> [#VarBind, a, e]
              | pattern:p ws fnBody:e   -> [#Let, p[0], [#Fn, p, e]],

  fnBody = posC:c ws "=>" ws ( condExpr:e -> [e, c]
                             | expr:e     -> [[#Ret, e], c]
                             ),

  condExpr = condCase:x (ws condCase)*:xs -> [#Cond, [x].concat(xs)],
  condCase = '|' ws expr:t ws "=>" ws expr:e -> [#CondCase, t, e],

  // Program
  program = ws module:m ws eof -> { m[3] = true; [#Program, m[1][0], m] }
}
