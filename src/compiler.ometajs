// Copyright (c) 2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var _ = require('./codegen')

ometa Compiler {
  sId :a                            -> _.identifier(a),
  Id :a                             -> _.string(a),
  Var :a                            -> _.identifier(a),
  Num :a :b                         -> _.number(a, b),
  Bool :a                           -> _.bool(a),
  List [cc*:xs]                     -> _.list(xs),
  Str :a                            -> _.string(a),
  Map [cc*:elms]                    -> _.map(elms),
  MapField cc:k cc:v                -> [k, v],
  App cc:scope cc:id [cc*:args]     -> _.app(scope, id, args),
  FnApp cc:fn [cc*:args]            -> _.call(fn, args),
  Member cc:a cc:b                  -> _.member(a, b),
  Lambda [scc*:args] [cc:e :c]      -> _.lambda(null, args, e, [[]]),
  Fn [scc:id [scc*:args] [cc*:cs]] [cc:e cc:c]  -> _.lambda(id, args, e, [cs, c]),
  FFI cc:code                       -> _.parseExpr(code.value),
  FFIStmt cc:code                   -> _.parseProg(code.value),
  IfExpr cc:t cc:c cc:a             -> _.ifExpr(t, c, a),
  Ret cc:e                          -> _.retExpr(e),
  Cond [cc*:xs]                     -> _.cond(xs),
  CondCase cc:t cc:e                -> [t, e],

  Let cc:id cc:val                  -> _.letStmt(id, val),
  Mod [cc:id [cc*:args] [cc*:cs]] [cc*:body] :t -> _.module(id, args, body, [cs, null], t),
  Export cc:id anything?:unpack     -> _.exportStmt(id, unpack),
  Program cc:id cc:mod              -> _.program(id, mod),
  Deco cc:f cc:id cc:e              -> _.decorator(f, id, e),

  Import cc:p cc:ks cc:id           -> _.importStmt(p, ks, id),
  ImpKw cc:id [cc*:args]            -> [id, args],
  Use cc:e                          -> _.use(e),

  IFace cc:id [cc*:decl]            -> _.ifaceStmt(id, decl),
  Impl cc:proto cc:tag [cc*:impl]   -> _.implStmt(proto, tag, impl),
  IMeth cc:c cc:a [cc*:args] [cc*:cs] -> _.ifaceMethDecl(a, args, [cs, c]),
  DMeth [cc:id [cc*:args] :__] cc:val -> _.ifaceMethDef(id, args, val),
  INeed cc:e                        -> _.ifaceNeed(e),
  Meth cc:id cc:val                 -> [id, val],

  VarBind scc:id cc:e               -> _.decl(id, e),
  Bind [cc*:vars] cc:e              -> _.binding(vars, e),

  Data cc:id [cc*:cases]            -> _.adtStmt(id, cases),
  DataCtor [:t cc:id [cc*:args] [cc*:cs]]    -> [t, id, args, [cs, null]],

  Case [cc*:vs] [cc*:xs]            -> _.caseStmt(vs, xs),
  CPatt [cc*:patts] cc:e            -> _.casePatt(patts, e),
  CaseAny                           -> _.caseAny(),
  CaseVal cc:a                      -> _.caseVal(a),
  CaseVar scc:a                     -> _.caseVar(a),
  CaseId cc:a                       -> _.caseId(a),
  CaseUn cc:tag cc:arg              -> _.caseUn(tag, arg),
  CaseBin cc:tag [cc:l cc:r]        -> _.caseBin(tag, l, r),
  CaseKw cc:tag [cc*:args]          -> _.caseKw(tag, args),

  Multi cc*:as                      -> as,
  Nil                               -> null,
  Empty                             -> _.empty(),
  Partial                           -> _.partial(),

  scc [:t apply('s' + t):a] -> a,
  cc [:t apply(t):a] -> a,
}
