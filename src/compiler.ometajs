// Copyright (c) 2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var _ = require('./codegen')

ometa Compiler {
  sId :a                            -> _.identifier(a),
  Id :a                             -> _.string(a),
  Var :a                            -> _.identifier(a),
  Num :a :b                         -> _.number(a, b),
  Bool :a                           -> _.bool(a),
  Str :a                            -> _.string(a),
  App cc:scope cc:id [cc*:args]     -> _.app(scope, id, args),
  FnApp cc:fn [cc*:args]            -> _.call(fn, args),
  Member cc:a cc:b                  -> _.member(a, b),
  Lambda [scc*:args] cc:expr        -> _.lambda(null, args, expr),
  Fn [scc:id [scc*:args]] cc:expr   -> _.lambda(id, args, expr),
  FFI cc:code                       -> _.parseExpr(code.value),

  Use cc:e                          -> _.use(e),
  Let cc:id cc:val                  -> _.letStmt(id, val),
  Mod [cc:id [cc*:args]] [cc*:body] -> _.module(id, args, body),
  Export cc:id                      -> _.exportStmt(id),
  Program cc:id cc:mod              -> _.program(id, mod),

  IFace cc:id [cc*:decl]            -> _.ifaceStmt(id, decl),
  Impl cc:proto cc:tag [cc*:impl]   -> _.implStmt(proto, tag, impl),
  IMeth cc:a [cc*:args]             -> _.ifaceMethDecl(a, args),
  DMeth [cc:id [cc*:args]] cc:val   -> _.ifaceMethDef(id, args, val),
  Meth cc:id cc:val                 -> [id, val],

  Data cc:id [cc*:cases]            -> _.adtStmt(id, cases),
  DataCtor [:t cc:id [cc*:args]]    -> [t, id, args],

  Case cc:v [cc*:xs]                -> _.caseStmt(v, xs),
  CPatt cc:patt cc:e                -> patt(e),
  CaseAny                           -> _.caseAny(),
  CaseVal cc:a                      -> _.caseVal(a),
  CaseId cc:a                       -> _.caseId(a),
  CaseUn cc:tag [scc:arg]           -> _.caseUn(tag, arg),
  CaseBin cc:tag [scc*:args]        -> _.caseBin(tag, args),
  CaseKw cc:tag [scc*:args]         -> _.caseKw(tag, args),

  Multi cc*:as                      -> as,

  scc [:t apply('s' + t):a] -> a,
  cc [:t apply(t):a] -> a,
}
